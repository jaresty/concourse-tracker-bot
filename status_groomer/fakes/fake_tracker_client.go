// This file was generated by counterfeiter
package fakes

import (
	"sync"

	"github.com/jaresty/concourse-tracker-bot/status_groomer"
	"github.com/jaresty/concourse-tracker-bot/tracker"
)

type FakeTrackerClient struct {
	StoriesStub        func(int, string) ([]tracker.Story, error)
	storiesMutex       sync.RWMutex
	storiesArgsForCall []struct {
		arg1 int
		arg2 string
	}
	storiesReturns struct {
		result1 []tracker.Story
		result2 error
	}
	CreateStoryStub        func(int, tracker.Story) (tracker.Story, error)
	createStoryMutex       sync.RWMutex
	createStoryArgsForCall []struct {
		arg1 int
		arg2 tracker.Story
	}
	createStoryReturns struct {
		result1 tracker.Story
		result2 error
	}
	ListCommentsStub        func(int, int) ([]tracker.Comment, error)
	listCommentsMutex       sync.RWMutex
	listCommentsArgsForCall []struct {
		arg1 int
		arg2 int
	}
	listCommentsReturns struct {
		result1 []tracker.Comment
		result2 error
	}
	AddCommentStub        func(int, int, string) error
	addCommentMutex       sync.RWMutex
	addCommentArgsForCall []struct {
		arg1 int
		arg2 int
		arg3 string
	}
	addCommentReturns struct {
		result1 error
	}
}

func (fake *FakeTrackerClient) Stories(arg1 int, arg2 string) ([]tracker.Story, error) {
	fake.storiesMutex.Lock()
	fake.storiesArgsForCall = append(fake.storiesArgsForCall, struct {
		arg1 int
		arg2 string
	}{arg1, arg2})
	fake.storiesMutex.Unlock()
	if fake.StoriesStub != nil {
		return fake.StoriesStub(arg1, arg2)
	} else {
		return fake.storiesReturns.result1, fake.storiesReturns.result2
	}
}

func (fake *FakeTrackerClient) StoriesCallCount() int {
	fake.storiesMutex.RLock()
	defer fake.storiesMutex.RUnlock()
	return len(fake.storiesArgsForCall)
}

func (fake *FakeTrackerClient) StoriesArgsForCall(i int) (int, string) {
	fake.storiesMutex.RLock()
	defer fake.storiesMutex.RUnlock()
	return fake.storiesArgsForCall[i].arg1, fake.storiesArgsForCall[i].arg2
}

func (fake *FakeTrackerClient) StoriesReturns(result1 []tracker.Story, result2 error) {
	fake.StoriesStub = nil
	fake.storiesReturns = struct {
		result1 []tracker.Story
		result2 error
	}{result1, result2}
}

func (fake *FakeTrackerClient) CreateStory(arg1 int, arg2 tracker.Story) (tracker.Story, error) {
	fake.createStoryMutex.Lock()
	fake.createStoryArgsForCall = append(fake.createStoryArgsForCall, struct {
		arg1 int
		arg2 tracker.Story
	}{arg1, arg2})
	fake.createStoryMutex.Unlock()
	if fake.CreateStoryStub != nil {
		return fake.CreateStoryStub(arg1, arg2)
	} else {
		return fake.createStoryReturns.result1, fake.createStoryReturns.result2
	}
}

func (fake *FakeTrackerClient) CreateStoryCallCount() int {
	fake.createStoryMutex.RLock()
	defer fake.createStoryMutex.RUnlock()
	return len(fake.createStoryArgsForCall)
}

func (fake *FakeTrackerClient) CreateStoryArgsForCall(i int) (int, tracker.Story) {
	fake.createStoryMutex.RLock()
	defer fake.createStoryMutex.RUnlock()
	return fake.createStoryArgsForCall[i].arg1, fake.createStoryArgsForCall[i].arg2
}

func (fake *FakeTrackerClient) CreateStoryReturns(result1 tracker.Story, result2 error) {
	fake.CreateStoryStub = nil
	fake.createStoryReturns = struct {
		result1 tracker.Story
		result2 error
	}{result1, result2}
}

func (fake *FakeTrackerClient) ListComments(arg1 int, arg2 int) ([]tracker.Comment, error) {
	fake.listCommentsMutex.Lock()
	fake.listCommentsArgsForCall = append(fake.listCommentsArgsForCall, struct {
		arg1 int
		arg2 int
	}{arg1, arg2})
	fake.listCommentsMutex.Unlock()
	if fake.ListCommentsStub != nil {
		return fake.ListCommentsStub(arg1, arg2)
	} else {
		return fake.listCommentsReturns.result1, fake.listCommentsReturns.result2
	}
}

func (fake *FakeTrackerClient) ListCommentsCallCount() int {
	fake.listCommentsMutex.RLock()
	defer fake.listCommentsMutex.RUnlock()
	return len(fake.listCommentsArgsForCall)
}

func (fake *FakeTrackerClient) ListCommentsArgsForCall(i int) (int, int) {
	fake.listCommentsMutex.RLock()
	defer fake.listCommentsMutex.RUnlock()
	return fake.listCommentsArgsForCall[i].arg1, fake.listCommentsArgsForCall[i].arg2
}

func (fake *FakeTrackerClient) ListCommentsReturns(result1 []tracker.Comment, result2 error) {
	fake.ListCommentsStub = nil
	fake.listCommentsReturns = struct {
		result1 []tracker.Comment
		result2 error
	}{result1, result2}
}

func (fake *FakeTrackerClient) AddComment(arg1 int, arg2 int, arg3 string) error {
	fake.addCommentMutex.Lock()
	fake.addCommentArgsForCall = append(fake.addCommentArgsForCall, struct {
		arg1 int
		arg2 int
		arg3 string
	}{arg1, arg2, arg3})
	fake.addCommentMutex.Unlock()
	if fake.AddCommentStub != nil {
		return fake.AddCommentStub(arg1, arg2, arg3)
	} else {
		return fake.addCommentReturns.result1
	}
}

func (fake *FakeTrackerClient) AddCommentCallCount() int {
	fake.addCommentMutex.RLock()
	defer fake.addCommentMutex.RUnlock()
	return len(fake.addCommentArgsForCall)
}

func (fake *FakeTrackerClient) AddCommentArgsForCall(i int) (int, int, string) {
	fake.addCommentMutex.RLock()
	defer fake.addCommentMutex.RUnlock()
	return fake.addCommentArgsForCall[i].arg1, fake.addCommentArgsForCall[i].arg2, fake.addCommentArgsForCall[i].arg3
}

func (fake *FakeTrackerClient) AddCommentReturns(result1 error) {
	fake.AddCommentStub = nil
	fake.addCommentReturns = struct {
		result1 error
	}{result1}
}

var _ status_groomer.TrackerClient = new(FakeTrackerClient)
